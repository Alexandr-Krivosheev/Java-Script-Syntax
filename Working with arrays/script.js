"use strict";
//Для хранения упорядоченных коллекций существует особая структура данных, которая называется массив, Array.

//===============================Обьявление массива ===============================================
let array = new Array(); //Не используется в практике
let arr = [];
//=================================================================================================

//==================== Обьявление и заполнение массива ============================================
//Элементы массива нумеруются, начиная с нуля.
// Мы можем получить элемент, указав его номер в квадратных скобках:
let cars = ['BMW', 'Mazda', 'Opel'];
console.log(cars[0]);
//Мы можем заменить элемент
cars[2] = 'Subaru';
console.log(cars[2]);
//Или добавить новый к существующему массиву
cars[3] = 'Kia';
console.log(cars);
//Общее число элементов массива содержится в его свойстве length
console.log(cars.length);
//В массиве могут храниться элементы любого типа.
let arrOne = ['hello', 42, {name: 'max'}, true, function () {
    console.log('Hello Mr.Trust');
}];
console.log(arrOne[2].name);
arrOne[4]();
//=================================================================================================

//=============================== Методы массива ==================================================
//Очередь – один из самых распространённых вариантов применения массива. В области компьютерных наук так
// называется упорядоченная коллекция элементов, поддерживающая два вида операций:
//push добавляет элемент в конец.
//shift удаляет элемент в начале, сдвигая очередь, так что второй элемент становится первым.
//Массивы поддерживают обе операции.
// На практике необходимость в этом возникает очень часто. Например, очередь сообщений, которые надо показать на экране.
// Существует и другой вариант применения для массивов – структура данных, называемая стек.
// Она поддерживает два вида операций:
// push добавляет элемент в конец.
// pop удаляет последний элемент.
// Таким образом, новые элементы всегда добавляются или удаляются из «конца».
// Примером стека обычно служит колода карт: новые карты кладутся наверх и берутся тоже сверху:
//Массивы в JavaScript могут работать и как очередь, и как стек. Мы можем добавлять/удалять элементы как в начало, так и в конец массива.
// В компьютерных науках структура данных, делающая это возможным, называется двусторонняя очередь.
// Методы, работающие с концом массива: pop(), push()
// pop() удаляет последний элемент из массива и возвращает его
console.log(cars.pop()); //удаляем "Kia" и выводим его
// push() добавляет элемент в конец массива
cars.push('Audi');
console.log(cars);
//Вызов cars.push(...) равнозначен cars[cars.length] = ...
//Методы, работающие с началом массива: shift(), unshift()
//shift() удаляет из массива первый элемент и возвращает его
console.log(cars.shift());
// unshift() добавляет элемент в начало массива
cars.unshift('Ford');
console.log(cars);
//Методы push и unshift могут добавлять сразу несколько элементов
cars.push('Honda', 'Lexus');
cars.unshift('Skoda', 'Jeep');
console.log(cars);

//==================================Внутреннее устройство массива========================================
//Массив – это особый подвид объектов. Квадратные скобки, используемые для того, чтобы получить доступ к свойству
// arr[0] – это по сути обычный синтаксис доступа по ключу, как obj[key], где в роли obj у нас arr,
// а в качестве ключа – числовой индекс.
// Массивы расширяют объекты, так как предусматривают специальные методы для работы с упорядоченными коллекциями
// данных, а также свойство length. Но в основе всё равно лежит объект.
// Следует помнить, что в JavaScript существует 8 основных типов данных.
// Массив является объектом и, следовательно, ведёт себя как объект.
// Например, копируется по ссылке
let car = ['BMW'];
let arrCar = car;
console.log(arrCar === car); //true
arrCar.push('Kia');
console.log(car, arrCar);
//Но то, что действительно делает массивы особенными – это их внутреннее представление. Движок JavaScript старается
// хранить элементы массива в непрерывной области памяти, один за другим, так, как это показано на иллюстрациях к этой
// главе. Существуют и другие способы оптимизации, благодаря которым массивы работают очень быстро.
// Но все они утратят эффективность, если мы перестанем работать с массивом как с «упорядоченной коллекцией данных»
// и начнём использовать его как обычный объект.
// Например, технически мы можем сделать следующее:
let arrs = [];
arrs[99999] = 5;
arrs.age = 25;
//Это возможно, потому что в основе массива лежит объект. Мы можем присвоить ему любые свойства.
// Но движок поймёт, что мы работаем с массивом, как с обычным объектом. Способы оптимизации, используемые для
// массивов, в этом случае не подходят, поэтому они будут отключены и никакой выгоды не принесут.
// Варианты неправильного применения массива:
// Добавление нечислового свойства, например: arr.test = 5.
// Создание «дыр», например: добавление arr[0], затем arr[1000] (между ними ничего нет).
// Заполнение массива в обратном порядке, например: arr[1000], arr[999] и т.д.
//Массив следует считать особой структурой, позволяющей работать с упорядоченными данными. Для этого массивы
// предоставляют специальные методы. Массивы тщательно настроены в движках JavaScript для работы с однотипными
// упорядоченными данными, поэтому, пожалуйста, используйте их именно в таких случаях.
// Если вам нужны произвольные ключи, вполне возможно, лучше подойдёт обычный объект {}

//==================================== Эфективность ===========================================================
//Методы push/pop выполняются быстро, а методы shift/unshift – медленно
//Почему работать с концом массива быстрее, чем с его началом? Давайте посмотрим, что происходит во время выполнения:
//Просто взять и удалить элемент с номером 0 недостаточно. Нужно также заново пронумеровать остальные элементы.
// Операция shift должна выполнить 3 действия:
// Удалить элемент с индексом 0.
// Сдвинуть все элементы влево, заново пронумеровать их, заменив 1 на 0, 2 на 1 и т.д.
// Обновить свойство length .

//Чем больше элементов содержит массив, тем больше времени потребуется для того, чтобы их переместить, больше операций с памятью.

// То же самое происходит с unshift: чтобы добавить элемент в начало массива, нам нужно сначала сдвинуть существующие элементы вправо, увеличивая их индексы.
// А что же с push/pop? Им не нужно ничего перемещать. Чтобы удалить элемент в конце массива, метод pop очищает индекс и уменьшает значение length.
//Метод pop не требует перемещения, потому что остальные элементы остаются с теми же индексами. Именно поэтому он выполняется очень быстро.
// Аналогично работает метод push.

//=================================Перебор элементов =========================================================
//Одним из самых старых способов перебора элементов массива является цикл for по цифровым индексам:
for (let i = 0; i < cars.length; i++){
    console.log(cars[i]);
}
//Но для массивов возможен и другой вариант цикла, for..of
for (let i of cars){
    console.log(i);
}
//Цикл for..of не предоставляет доступа к номеру текущего элемента, только к его значению, но в большинстве случаев этого достаточно. А также это короче.
// Технически, так как массив является объектом, можно использовать и вариант for..in:
for (let key in cars){
    console.log(cars[key]);
}
//Но на самом деле это – плохая идея. Существуют скрытые недостатки этого способа:
// Цикл for..in выполняет перебор всех свойств объекта, а не только цифровых.
// В браузере и других программных средах также существуют так называемые «псевдомассивы» – объекты, которые выглядят,
// как массив. То есть, у них есть свойство length и индексы, но они также могут иметь дополнительные нечисловые свойства
// и методы, которые нам обычно не нужны. Тем не менее, цикл for..in выведет и их. Поэтому, если нам приходится иметь дело
// с объектами, похожими на массив, такие «лишние» свойства могут стать проблемой.
// Цикл for..in оптимизирован под произвольные объекты, не массивы, и поэтому в 10-100 раз медленнее.
// Увеличение скорости выполнения может иметь значение только при возникновении узких мест. Но мы всё же должны представлять разницу.
// В общем, не следует использовать цикл for..in для массивов.

//===========================================Немного о length ==================================================
//Свойство length автоматически обновляется при изменении массива. Если быть точными, это не количество элементов массива, а наибольший цифровой индекс плюс один.
// Например, единственный элемент, имеющий большой индекс, даёт большую длину:
const mas = [];
mas[125] = 'hi';
console.log(mas.length);
//Обратите внимание, что обычно мы не используем массивы таким образом.
// Ещё один интересный факт о свойстве length – его можно перезаписать.
// Если мы вручную увеличим его, ничего интересного не произойдёт. Зато, если мы уменьшим его, массив станет короче.
// Этот процесс необратим, как мы можем понять из примера:
let massiv = [1, 2]
